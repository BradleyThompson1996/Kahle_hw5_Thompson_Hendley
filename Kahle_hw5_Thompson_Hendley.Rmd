---
title: "Thompson_Hendley_hw5"
author: "Bradley Thompson & John Hendley"
date: "11/18/2020"
output: pdf_document
---

```{r setup, echo=FALSE, results=TRUE}
knitr::opts_chunk$set(error=TRUE, dev="cairo_pdf")
library(tidyverse)
```

## Number 1
``` {r Num1}
# Takes the basic color palette and spreads it into 50 colors
expand_palette <- function(n, colors) {
  spread <- colorRampPalette(colors)
  spread(n)
}

colors <- brewer.pal(9, "Spectral")
more_colors <- expand_palette(50, colors)
show_col(more_colors, labels = FALSE)
```


## Number 2
```{r, echo = FALSE}
#dot
dot <- function(x, y){
  if (length(x) != length(y)) stop("vectors `x` and `y` are not of the same length.")
  # loop over the vector, accumulating the inner product
  out <- 0 
  for (i in seq_along(x)) out <- out + x[i]*y[i]# return inner product
  out
}

#norm 
norm <- function(x) sqrt(dot(x, x))

#normalize
normalize <- function(x) x / norm(x)

#is zero
is.zero <- function(x) norm(x) < sqrt(.Machine$double.eps)

#projection
project_onto <- function(y,x){
  projection <- c(1:length(x))
  if(is.zero(x)){
    for(i in 1:length(x)){
      projection[i] <- 0
    }
  }
  else{
    projection <- dot(y,x)/dot(x,x)*x
  }
  projection
}
# project_onto <- function(y, x, normalized_x = FALSE){
#   stopifnot(length(x) == length(y))
#   if (is.zero(x)) return(rep(0, length(x)))
#   if (normalized_x) dot(y, x) * x else dot(y, x) / dot(x, x) * x
# }
#discard zero cols
discard_zero_cols <- function(M) M[,!apply(M, 2, is.zero)]


#gs
gs <- function(A){
  # initialize basis matrix
  e <- matrix(0, nrow = nrow(A), ncol = ncol(A))
  e[,1L] <- normalize(A[,1L])
  # orthogonalize and normalize column by column
  for (j in 2L:ncol(A)){
    e_tilde <- A[,j]
    # subtract parallel components
    for (k in 1L:(j-1L)){
      e_tilde <- e_tilde - project_onto(e_tilde, e[,k]
                                        #, normalized_x = TRUE
                                        )
      }
    # normalize
    if (norm(e_tilde) < sqrt(.Machine$double.eps)){
      e[,j] <- rep(0, nrow(A))
      }else{
        e[,j] <- normalize(e_tilde)}
    }# end for loop over columns
  # return
  discard_zero_cols(e)
}
```

1)
```{r}
#code for question 1
```

2)
```{r}
#need to figure out either why doesn't go back into for loop
#or why the rest of the columns are 0's
mgs <- function(A){
  #skeleton of Q and define ai = (a_i)
  Q <- matrix(0, nrow = nrow(A), ncol = ncol(A))
  ai <- A[, 1]
  
  #getting Q
  for(i in seq_along(ncol(Q))){
    Q[, i] <- normalize(ai)
    #checking for 0 cols
    if(norm(ai) != 0 & i != ncol(Q)){
      #redefining a_i
      for(j in (i+1):ncol(Q)){
        ai <- ai - project_onto(A[, j], Q[, i])
      }
    }
  }
  #return
  discard_zero_cols(Q)
}

#testing
A <- matrix(c(1, 6, 19, 2,1, 2,  7, 3,5, 6, 23, 2), nrow = 3, byrow = TRUE)
gs(A)
mgs(A)
```

3)
```{r}
#code for 3
```

## Number 4
```{r Num4}
library(tibble)

# spy <- function(mat) {
#   
# }

# n <-  50
# mat <- matrix(0L, nrow = n, ncol = n)
# set.seed(2L)
# mat[sample(n^2, n)] <- rpois(n, 5)

n <- 10

df <- tibble(
  x = 1:10,
  y = 10:1
)

ggplot(df, aes(x, y)) +
  geom_rect(aes(xmin = 0.5, xmax = n + 0.5, 
            ymin = 0.5, ymax = n + 0.5), 
            fill = "white", color = "black", size = 0.2) +
  geom_tile(fill = "black") +
  scale_x_continuous(name = NULL, breaks = NULL, minor_breaks = NULL) +
  scale_y_continuous(name = NULL, breaks = NULL, minor_breaks = NULL) +
  coord_equal()

```

